import { createReadStream, createWriteStream, type PathLike } from "node:fs";
import { unlink } from "node:fs/promises";
import type { Transform } from "node:stream";
import {
	createBrotliCompress,
	createGzip,
	createZstdCompress,
} from "node:zlib";
import { UnsupportedError } from "../../ecma/error/unsupported-error.js";
import { defaults } from "../../ecma/object/defaults.js";

export enum CompressFileExtension {
	BROTLI = ".br",
	GZIP = ".gz",
	ZSTD = ".zst",
}

export type CompressFileOptions = {
	/**
	 * The compression algorithm to use.
	 *
	 * Default is `CompressFileExtension.GZIP`.
	 */
	fileType?: CompressFileExtension;

	/**
	 * Whether to keep the source file after compression.
	 *
	 * Default is `false`.
	 */
	keepSource?: boolean;

	/**
	 * An `AbortSignal` to cancel the operation.
	 */
	signal?: AbortSignal | null;
};

const COMPRESS_FILE_DEFAULT_OPTIONS: Required<CompressFileOptions> = {
	fileType: CompressFileExtension.GZIP,
	keepSource: false,
	signal: null,
};

/**
 * Compress a file using the specified compression algorithm.
 *
 * The destination file path can be omitted, in which case it will be generated
 * by appending the appropriate file extension to the source file path.
 *
 * By default, the source file will be deleted after compression. This can be
 * changed by setting the `keepSource` option to `true`.
 *
 * Supported compression algorithms are Brotli, Gzip, and Zstd.
 *
 * @param src The path to the source file.
 * @param dest The path to the destination file. If omitted, it will be
 * generated by appending the appropriate file extension to the source file path.
 * @param options Compression options.
 * @returns The path to the compressed file.
 */
export async function compressFile(
	src: PathLike,
	dest?: PathLike | null,
	options?: CompressFileOptions,
): Promise<PathLike> {
	const effectiveOptions = defaults(options, COMPRESS_FILE_DEFAULT_OPTIONS);

	if (!dest) {
		if (src instanceof URL) {
			dest = new URL(src);
			dest.pathname += effectiveOptions.fileType;
		} else if (Buffer.isBuffer(src)) {
			dest = Buffer.concat([src, Buffer.from(effectiveOptions.fileType)]);
		} else {
			dest = `${src}${effectiveOptions.fileType}`;
		}
	}

	let compressionStream: Transform;

	switch (effectiveOptions.fileType) {
		case CompressFileExtension.BROTLI:
			compressionStream = createBrotliCompress();
			break;

		case CompressFileExtension.GZIP:
			compressionStream = createGzip();
			break;

		case CompressFileExtension.ZSTD:
			compressionStream = createZstdCompress();
			break;

		default:
			throw new UnsupportedError(`file type "${effectiveOptions.fileType}"`);
	}

	await new Promise<void>((resolve, reject) => {
		createReadStream(src, { signal: effectiveOptions.signal })
			.pipe(compressionStream)
			.pipe(createWriteStream(dest))
			.once("error", reject)
			.once("finish", resolve);
	});

	if (!options?.keepSource) {
		await unlink(src);
	}

	return dest;
}
